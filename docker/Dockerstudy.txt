docker 网络

Host 模式介绍：
容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口。
1、容器与主机在相同的网络命名空间下面，使用相同的网络协议栈，容器可以直接使用主机的所有网络接口
2、host 模式不能使用端口映射和自定义路由规则，这些都与主机一致，-p 与-icc 参数是无效的
3、host 模式下面的网络模型是最简单和最低延迟的模式，容器进程直接与主机网络接口通信，与物理机性能一致

container模式
与一个已存在的容器共享一个网络空间。
而不是和宿主机共享。新创建的容器不会创建自己的网卡，配置自己的IP，而是和一个指定的容器共享IP、端口范围等。
同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。两个容器的进程可以通过lo网卡设备通信。

none
不使用网络。


bridge 网络模型介绍
默认网络
1、每一个容器使用自己的网络命名空间
2、每个容器的网络与主机的bridge 设备连接（主机与容器通信，容器间通信）
3、主机NAT（端口映射） 容器里面的数据包ip 与外部通信
4、官网推荐使用自定义bridge 网络，不使用默认的docker0。
自定义的bridge 比docker 默认的bridge 网络有更多功能和灵活性，详情见官网
5、各个bridge 里面的网络隔离，实现了自己局网连通，隔离其他局网
在bridge模式下，连在同一网桥上的容器可以相互通信
（若出于安全考虑，也可以禁止它们之间通信，方法是在DOCKER_OPTS变量中设置–icc=false，这样只有使用–link才能使两个容器通信）
Docker可以开启容器间通信（意味着默认配置--icc=true），也就是说，宿主机上的所有容器可以不受任何限制地相互通信，
这可能导致拒绝服务攻击。进一步地，Docker可以通过--ip_forward和--iptables两个选项控制容器间、容器和外部世界的通信。

自定义网络模式
bridge，overlay，MACVLAN

overlay
跨主机容器通讯

macvlan
每个容器虚拟一张带mac的网卡，基于虚拟vlan通讯。由mac绑定vlan。适合会频繁变动网络拓扑的情况。









docker 安装

curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun
yum install -y yum-utils   device-mapper-persistent-data   lvm2
yum-config-manager     --add-repo     http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
yum install docker-ce docker-ce-cli containerd.io
yum install docker-ce-19.03.9-3.el7 docker-ce-cli-19.03.9-3.el7 containerd.io
systemctl start docker

docker加速
echo '{
    "registry-mirrors":["https://almtd3fa.mirror.aliyuncs.com"]

}' >> /etc/docker/daemon.json
echo "deb http://mirrors.163.com/debian/ jessie main non-free contrib
deb http://mirrors.163.com/debian/ jessie-proposed-updates main non-free contrib
deb-src http://mirrors.163.com/debian/ jessie main non-free contrib
deb-src http://mirrors.163.com/debian/ jessie-proposed-updates main non-free contrib" >>/etc/apt/sources.list
systemctl restart docker

修改docker存储目录
systemctl stop docker
mkdir -p /home/docker/lib
mkdir -p /etc/systemd/system/docker.service.d/
echo " [Service]
ExecStart=
ExecStart=/usr/bin/dockerd  --graph=/home/docker/lib/docker " >> /etc/systemd/system/docker.service.d/devicemapper.conf
systemctl daemon-reload
systemctl restart docker
systemctl enable docker
查看目录是否为/home/docker/lib/docker
docker info




docker操作

查找image
docker search [imagename]

上传image
docker push [imagename]
本地上传到私有仓库
docker push IP:端口/image-name

拉取镜像
docker pull containername:taget
            容器名：标签
默认为最新版本


docker导出本地容器
docker export 58dbc2162141 > tomcat.tar
              容器ID/容器名    导出文件名及路径
导入到本地容器
docker import - new_tomcat_server < tomcat.tar
                    新镜像名          导入文件名及路径

docker导出本地镜像
docker save busybox-1 > /home/save.tar
            镜像名         导出文件名及路径
            不要用镜像ID，否则镜像名和标签都会是none
导入到本地镜像
docker load < /home/save.tar

save更完整，import会丢失镜像历史，无法做层回滚。
docker使用

重命名镜像
docker tag [镜像id] [新镜像名称]:[新镜像标签]

查看docker 网络
docker network ls
查看某个网络ID/网络模式的详细信息
docker network inspect networkID/networkTYPE

创建自定义网络
docker network create -d bridge mynet2
删除网络
docker network rm mynet2

查看bridge网络信息
yum install -y bridge-utils
brctl show

docker run -itd --nat bridge --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=gemhone2016 mysql:5.6.36
					以什么网络启动	    容器名  主机端口:容器端口								基础镜像及标签

docker run -itd -p 8090:8080  -v /home/jenkins/jenkins_data/:/home/jenkins/jenkins_data/ tomcat_test
									主机目录					挂载于容器目录
可以使用-v来创建或者指定一个数据卷/单个文件挂载到容器里，一次run可挂载多个数据卷
类似mount 权限默认读写，只读用:ro指定
挂载数据卷容器使用--volumes-from
数据卷容器不需要保持在运行状态
可以利用这个来保存、备份、迁移容器数据

-e #指定环境变量    格式：环境变量：值
-d #后台运行容器，并返回容器ID
-i #以交互式模式运行容器,让标准输出保持打开，常与-t参数同时使用
-t #给容器重新分配一个伪终端，添加tag，指定新镜像的用户信息，常与-i参数同时使用
–name #给容器指定一个名称  容器名唯一
-b 指定容器挂载网桥
-icc=true|false 是否支持容器间通信，默认支持
-iptables=true|false 是否允许docker添加iptables规则
-dns=xxx 指定容器DNS服务器，默认主机/etc/resolv.conf 里的配置

docker run -it -v $(pwd)/host-dava:/container-data alpine sh

docker exec -it containername /bin/bash -c 'command'
宿主机执行docker容器命令，如涉及环境变量。添加export 环境变量
-u 指定执行命令的用户


容器通外网需要设置本机开启路由转发，同时在启动docker时添加--ip-foeward=true
查看容器端口映射情况
docker port 容器名 映射后的端口

容器互联 --link
docker run -d -p --name wed --link db:db  training/webapp python app.py
                   要连接的容器的名称:连接的别名
其中连接信息在环境变量及/etc/hosts中
可使用 env查看
docker run --rm --name web2 --link db:db training/webapp env
或者查看父容器的hosts
docker run -ti -rm --link db:db training/webapp /bin/bash
root@xxxxx:/opt/webapp#cat /etc/hosts
其中，第一行是父容器名		第二行是连接的容器名
可安装ping命令来测试容器间的网络连通性。


给正在运行的容器添加环境变量
添加在如下两个文件
/etc/profile
/{user}/.bashrc
再source即可生效

docker打包正在运行的镜像
docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]

-a :提交的镜像作者；
-c :使用Dockerfile指令来创建镜像；
-m :提交时的说明文字；
-p :在commit时，将容器暂停。

默认情况下，正在提交的容器及其进程将在映像提交时暂停。 这减少了在创建提交过程中遇到数据损坏的可能性。 如果不需要此行为，请将--pause选项设置为false。
-c 选项将对创建的映像应用Dockerfile指令。支持Dockerfile指令 CMD|ENTRYPOINT|ENV|EXPOSE|LABEL|ONBUILD|USER|VOLUME|WORKDIR


docker在运行容器添加暴露端口
firewall-cmd --add-forward-port=port=7082:proto=tcp:toaddr=172.17.0.2:toport=7082 --permanent
                             主机暴露端口                        容器IP：容器暴露端口
添加对应链的防火墙规则
iptables -I INPUT 1 -p tcp  -m state --state NEW -m tcp --dport 7082 -j ACCEPT
iptables -I DOCKER 1  -p tcp  -m state --state NEW -m tcp --dport 7082 -j ACCEPT
iptables -I IN_public_allow 1  -p tcp  -m state --state NEW -m tcp --dport 7082 -j ACCEPT


dockerfile


分为四部分：
基础镜像信息、维护者信息、镜像操作指令、容器启动时的执行指令

其中
FROM 指明基础镜像，同时创建多个镜像时，可多个FROM，每个镜像一次，且FROM必须为第一条指令。

MAINTAINER 指定维护者/镜像编辑者的邮件地址

ENV 指定环境变量，会被后续RUN指令使用，在容器运行时保持。
格式 ENV <key> <value>

RUN 对镜像执行的指令，每运行一条RUN，镜像添加一层可读层，并提交为新的镜像。
基本格式：
RUN <command> 或 RUN ["executable"，"param1"，"param2"]
前者为将在shell终端运行的命令；后者为exec执行的可执行文件。指定其他终端可使用后者实现，如 RUN ["/bin/bash","-C","hello word"]

ENTRPOINT
基本格式：
ENTRPOINT ["executable","param1","param2"]  使用exec执行
ENTRPOINT command param1 param2 在/bin/bash中执行，提供给需要交互的应用
每个dockerfile只能有一个ENTRPOINT，指定多个时，最后一个生效

VOLUME 创建一个从本地主机或本地其他容器的挂载点
VOLUME ["/data"]

EXPOSE 指定容器暴露的端口号，启动容器时需要指定-P docker主机会自动分配端口转发到此端口

USER 指定运行容器的用户名及UID，后续RUN也会使用这个指定用户

WORKDIR 为后续的RUN、CMD、ENTRPOINT指定配置的工作目录
使用多个WORKDIR 后续命令参数为相对路径，则会继承之前WORKDIR路径

ONBUILD 配置所创建镜像为其他新镜像的基础镜像
ONBUILD [INSTRUCTION]
如
...
ONBUILD ADD . /app/src
ONBUILD RUN /usr/local/bin/python-build --dir /app/src
...
以上为镜像image-A

FROM image-A指定image-A为基础镜像时，ONBUILD就等价于以下两条命令:
ADD . /app/src
RUN /usr/local/bin/python-build --dir /app/src

ADD/COPY 指定文件到容器中
格式 ADD/COPY <src> <dest>  其中，源地址可以是dockerfile所在目录的相对路径、url；tar包会自动解压为目录
源地址为本地目录时建议使用COPY

CMD 指定容器运行时的操作指令
基本格式：
CMD ["executable","param1","param2"]  使用exec执行
CMD command param1 param2 在/bin/bash中执行，提供给需要交互的应用
CMD ["param1","param2"] 提供给ENTRYPOINT的默认参数
每个dockerfile只能有一条CMD命令，如果指定多条，只有最后一条会被执行。
如果启动容器时指定了运行命令，则会覆盖掉CMD指定的命令

创建镜像：
编写玩dockerfile后，可使用docker build来创建镜像
docker build [选项] 路径
该命令将会读取路径下（包括字目录）的dockerfile，并将其中dockerfile发送给docker服务端，由服务端来创建镜像



/usr/bin/docker-current: Error response from daemon: error creating overlay mount to /var/lib/docker/overlay2/d59b250eebf427a7bbd36dd1a834a969? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?196589187a77720e0148985ddae6ce13-init/merged: invalid argument.
See '/usr/bin/docker-current run --help'.

因为image用的overlay2文件系统，而系统默认只能识别overlay文件系统

更新文件系统
systemctl stop docker
rm -rf /var/lib/docker #会删除docker images
vi /etc/sysconfig/docker-storage
指定 DOCKER_STORAGE_OPTIONS="--storage-driver overlay"

vi /etc/sysconfig/docker
#OPTIONS='--selinux-enabled --log-driver=journald --signature-verification=false'
改为
OPTIONS='--log-driver=journald --signature-verification=false'

systemctl start docker

注意：一个镜像不能超过127层
